问题描述：已知一个正整数序列，个数未知，但至少有一个元素，你的任务是建立一个单链表，并使用该链表存储这个正整数序列，然后统计这个序列中元素的最大值与最小值，计算序列全部元素之和。正整数的输入用-1作为结束标志，注意-1不算这个正整数序列中的元素（不要统计-1）。
输入与输出要求：输入一个正整数序列，正整数序列元素的个数未知，但以输入“-1”结束，输入“-1”前至少输入一个正整数。序列中的元素范围在1—999999999之间。输出三个正整数，即最大值、最小值、所有元素之和。
数据最多的测试用例节点数在1000这个数量级，所有整数可以用int型存储。
请注意输入输出格式。

输入样例
1 4 99 21 50 61 32 4 -1
输出样例
The maximum,minmum and the total are:99 1 272

#include<stdio.h>
#include<stdlib.h>
typedef struct _node
{
	int data;
	struct _node* nextPtr;
}Node;//Node现在就是一个类型了

Node* createList();
void DestroyList(Node** sPtr);
int findMax(Node** sPtr);
int findMin(Node** sPtr);
int sumlist(Node** sPtr);

int main(int argc, char const *argv[])
{
	Node *list=createList();
	int min=findMin(&list);
	int max=findMax(&list);
	int sum=sumlist(&list);
	printf("The maximum,minmum and the total are:%d %d %d\n",max,min,sum);
	DestroyList(&list);
	return 0;
}

Node *createList()
{
	Node *currentPtr=NULL,*headPtr=NULL,*lastPtr=NULL;
	int num;
	scanf("%d",&num);
	while(num!=-1)
	{
		currentPtr=(Node*)malloc(sizeof(Node));//(Node*)是什么？ 
		currentPtr->data=num;
		lastPtr->nextPtr=currentPtr;
		lastPtr=currentPtr;	
	
	if (headPtr==NULL)
	{
		headPtr=currentPtr;
	}
	scanf("%d",&num);
	}
	lastPtr->nextPtr=NULL;
	return headPtr;
} 

void DestroyList(Node **sPtr)
{
	Node *headPtr=*sPtr,*tmpPtr;
	while(headPtr)
	{
		tmpPtr=headPtr;
		headPtr=headPtr->nextPtr;
		free(tmpPtr);
	}
	*sPtr=NULL;
}

int findMax(Node** sPtr)
{
	Node *headPtr=*sPtr;
	int result=headPtr->data;
	headPtr=headPtr->nextPtr;
	while(headPtr)
	{
		if (result<headPtr->data) result= headPtr->data;
		headPtr=headPtr->nextPtr;
	}
	return result;
}

int findMin(Node** sPtr)
{
	Node *headPtr=*sPtr;
	int result=headPtr->data;
	headPtr=headPtr->nextPtr;
	while(headPtr)
	{
		if (result>headPtr->data) result= headPtr->data;
		headPtr=headPtr->nextPtr;
	}
	return result;
}

int sumlist(Node** sPtr)
{
	Node *headPtr=*sPtr;
	int sum=0;
	while(headPtr)
	{
		sum=sum+headPtr->data;
		headPtr=headPtr->nextPtr;
	}
	return sum;	
}
